This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  actions/
    setup-bun/
      action.yml
  workflows/
    ci-post-merge.yml
    ci-pre-merge.yml
apps/
  api/
    endpoints/
      foo.test.ts
      foo.ts
    utils/
      env.ts
    context.ts
    index.ts
    package.json
    README.md
    tsconfig.json
  cli/
    commands/
      add-foo.ts
      chat.ts
      get-foo.ts
      patch-foo.ts
    utils/
      app.ts
      flags.ts
      render.ts
    .gitignore
    index.ts
    package.json
    README.md
    tsconfig.json
packages/
  app/
    agent/
      utils/
        createSandboxTool.test.ts
        createSandboxTool.ts
        generateFunctionDocs.test.ts
        generateFunctionDocs.ts
        index.ts
        streamAgent.ts
        wrapStreamWithPromise.ts
      AiAgentService.test.ts
      AiAgentService.ts
      examples.ts
      index.ts
    core/
      CoreAppService.test.ts
      CoreAppService.ts
      index.ts
    index.ts
    package.json
    README.md
    tsconfig.json
  core/
    ports/
      repositories/
        ConversationRepository.ts
        FooRepository.ts
        index.ts
        MessageRepository.ts
    schema/
      utils/
        timestamps.ts
      conversation.ts
      foo.ts
      index.ts
      message.ts
    validators/
      conversation.ts
      foo.ts
      index.ts
      message.ts
    index.ts
    package.json
    README.md
    tsconfig.json
  db/
    db/
      index.ts
    repositories/
      ConversationRepository.test.ts
      ConversationRepository.ts
      FooRepository.test.ts
      FooRepository.ts
      index.ts
      MessageRepository.test.ts
      MessageRepository.ts
    test-utils/
      seed/
        all.ts
        conversation.ts
        foo.ts
        index.ts
        message.ts
      db.ts
      index.ts
    index.ts
    package.json
    README.md
    tsconfig.json
tests/
  utils/
    db.ts
  api.test.ts
  cli.test.ts
  package.json
  tsconfig.json
.gitignore
.prettierignore
.prettierrc
AGENTS.md
drizzle.config.ts
eslint.config.mjs
package.json
tsconfig.base.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/actions/setup-bun/action.yml">
name: "Setup Bun Environment"
description: "Checkout code, setup Bun, restore cache, and install dependencies"

runs:
  using: composite
  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Bun
      uses: oven-sh/setup-bun@v2
      with:
        bun-version: latest

    - name: Restore Bun cache
      uses: actions/cache@v4
      with:
        path: |
          ~/.bun/install/cache
          node_modules
        key: ${{ runner.os }}-bun-${{ hashFiles('bun.lock') }}
        restore-keys: |
          ${{ runner.os }}-bun-

    - name: Install dependencies
      shell: bash
      run: bun install --frozen-lockfile
</file>

<file path=".github/workflows/ci-post-merge.yml">
name: CI (Post-merge)

# Runs automatically on pushes to main. To test this workflow from a branch, name the branch
# using the "ci-post-merge/" prefix (e.g. ci-post-merge/update-workflow).
on:
  push:
    branches: [main, "ci-post-merge/**"]

jobs:
  typecheck:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun environment
        uses: ./.github/actions/setup-bun

      - name: Type check
        run: bun run typecheck

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun environment
        uses: ./.github/actions/setup-bun

      - name: Lint
        run: bun run lint

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun environment
        uses: ./.github/actions/setup-bun

      - name: Run tests
        run: bun run test
</file>

<file path=".github/workflows/ci-pre-merge.yml">
name: CI (Pre-merge)

on:
  pull_request:
    branches: [main]

jobs:
  typecheck:
    name: Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun environment
        uses: ./.github/actions/setup-bun

      - name: Type check
        run: bun run typecheck

  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun environment
        uses: ./.github/actions/setup-bun

      - name: Lint
        run: bun run lint

  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Bun environment
        uses: ./.github/actions/setup-bun

      - name: Run tests
        run: bun run test
</file>

<file path="apps/api/endpoints/foo.ts">
import { Elysia, t } from "elysia";
import type { Context } from "../context";
import { notFound } from "@hapi/boom";

const idParamsSchema = t.Object({
  id: t.String(),
});

const fooBodySchema = t.Object({
  name: t.String({ minLength: 3 }),
});

export const fooRoutes = ({ app }: Context) =>
  new Elysia({ prefix: "/foos" })
    .get(
      "/:id",
      async ({ params, status }) => {
        const result = await app.getFoo(params.id);
        if (!result) {
          throw notFound(`Foo with ID ${params.id} not found`);
        }
        return status(200, result);
      },
      { params: idParamsSchema }
    )
    .post(
      "/",
      async ({ body, status }) => {
        const result = await app.createFoo(body.name);
        return status(201, result);
      },
      { body: fooBodySchema }
    )
    .patch(
      "/:id",
      async ({ params, body, status }) => {
        const result = await app.patchFoo(params.id, body.name);
        return status(200, result);
      },
      { params: idParamsSchema, body: fooBodySchema }
    );
</file>

<file path="apps/api/utils/env.ts">
import { z } from "zod";
import path from "node:path";

export const env = z
  .object({
    PORT: z
      .string()
      .default("4000")
      .transform((val) => parseInt(val, 10)),
    DATABASE_URL: z
      .string()
      .min(1)
      .default(`file:${path.join(__dirname, "../../../data/sqlite.db")}`),
  })
  .parse(process.env);
</file>

<file path="apps/api/context.ts">
import { CoreAppService } from "@ai-starter/app";
import { getDB, getRepos } from "@ai-starter/db";

export interface Context {
  app: ReturnType<typeof CoreAppService>;
}

export function getContext(database: string): Context {
  const db = getDB(database);
  const repos = getRepos(db);
  const app = CoreAppService({ repos });

  return { app };
}
</file>

<file path="apps/api/package.json">
{
  "name": "@ai-starter/api",
  "module": "src/index.ts",
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "private": true,
  "type": "module",
  "dependencies": {
    "@ai-starter/app": "workspace:*",
    "@ai-starter/core": "workspace:*",
    "@ai-starter/db": "workspace:*",
    "@hapi/boom": "^10.0.1",
    "elysia": "^1.1.28",
    "zod": "^4.1.12"
  },
  "scripts": {
    "start": "bun run index.ts"
  }
}
</file>

<file path="apps/api/README.md">
# API

REST API built with Elysia that exposes the core application functionality.

## Running

```bash
bun run apps/api/src/index.ts
```

## Endpoints

- `GET /foos/:id` - Get a foo by ID
- `POST /foos` - Create a new foo
- `PATCH /foos/:id` - Update a foo's name
</file>

<file path="apps/api/tsconfig.json">
{
  "extends": "../../tsconfig.base.json"
}
</file>

<file path="apps/cli/utils/flags.ts">
export const FLAGS = {
  database: {
    type: String,
    alias: "d",
    description: "Database connection string",
    default: "file:data/sqlite.db",
  },
};
</file>

<file path="apps/cli/.gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="apps/cli/README.md">
# CLI App

This package contains the command-line interface (CLI) for interacting with the
application. It provides various commands to perform operations, and is
especially useful to allow an AI agent to actuate use-cases.
</file>

<file path="apps/cli/tsconfig.json">
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="packages/app/agent/utils/createSandboxTool.test.ts">
import { describe, expect, it } from "bun:test";
import { z } from "zod";
import {
  createSandboxTool,
  type SandboxFunction,
  type SandboxExecutionResult,
} from "./createSandboxTool";

// Helper type to extract the result type
type ExecuteResult = SandboxExecutionResult;

async function executeToolCode(
  tool: ReturnType<typeof createSandboxTool>,
  code: string
): Promise<ExecuteResult> {
  if (!tool.execute) {
    throw new Error("Tool execute function is not defined");
  }

  const result = await tool.execute(
    { code },
    { toolCallId: `test-${Math.random()}`, messages: [] }
  );

  // The result should be our SandboxExecutionResult, not an iterable
  if (Symbol.asyncIterator in Object(result)) {
    throw new Error("Unexpected async iterable result");
  }

  return result as ExecuteResult;
}

describe("createSandboxTool", () => {
  it("executes simple JavaScript code and returns output", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(tool, "return 1 + 1;");

    expect(result.output).toBe(2);
    expect(result.error).toBeUndefined();
    expect(result.logs).toEqual([]);
  });

  it("captures console.log output", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(
      tool,
      `
        console.log("Hello");
        console.log("World", 123);
        return "done";
      `
    );

    expect(result.output).toBe("done");
    expect(result.logs).toEqual(["Hello", "World 123"]);
    expect(result.error).toBeUndefined();
  });

  it("captures console.error output", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(
      tool,
      `
        console.error("Something went wrong");
        return "done";
      `
    );

    expect(result.output).toBe("done");
    expect(result.logs).toContain("ERROR: Something went wrong");
    expect(result.error).toBeUndefined();
  });

  it("handles runtime errors gracefully", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(
      tool,
      "throw new Error('Test error');"
    );

    expect(result.output).toBeUndefined();
    expect(result.error).toContain("Test error");
    expect(result.logs.some((log: string) => log.includes("ERROR:"))).toBe(
      true
    );
  });

  it("executes code with complex data types", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(
      tool,
      `
        const data = { name: "Alice", age: 30, tags: ["developer", "tester"] };
        return data;
      `
    );

    expect(result.output).toEqual({
      name: "Alice",
      age: 30,
      tags: ["developer", "tester"],
    });
    expect(result.error).toBeUndefined();
  });

  it("allows calling provided functions directly", async () => {
    const fetchData: SandboxFunction<
      { id: string },
      { id: string; name: string }
    > = {
      description: "Fetches data by ID",
      inputSchema: z.object({ id: z.string() }),
      execute: async ({ id }) => {
        return { id, name: `Item ${id}` };
      },
    };

    const tool = createSandboxTool({
      functions: { fetchData: fetchData as SandboxFunction<unknown, unknown> },
    });
    const result = await executeToolCode(
      tool,
      `
        const data = await fetchData({ id: "123" });
        console.log("Fetched data:", JSON.stringify(data));
        return data.name;
      `
    );

    expect(result.output).toBe("Item 123");
    expect(
      result.logs.some((log: string) => log.includes("Fetched data:"))
    ).toBe(true);
    expect(result.error).toBeUndefined();
  });

  it("validates function arguments against schema", async () => {
    const strictFunction: SandboxFunction<{ count: number }, number> = {
      description: "Requires a number",
      inputSchema: z.object({ count: z.number() }),
      execute: async ({ count }) => count * 2,
    };

    const tool = createSandboxTool({
      functions: {
        strictFunction: strictFunction as SandboxFunction<unknown, unknown>,
      },
    });
    const result = await executeToolCode(
      tool,
      `return await strictFunction({ count: "not a number" });`
    );

    expect(result.error).toBeDefined();
    expect(result.error).toMatchInlineSnapshot(`
      "âŒ Validation error in function 'strictFunction'

      ðŸ“‹ Expected schema:
      {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          }
        },
        "required": [
          "count"
        ],
        "additionalProperties": false
      }

      ðŸ“¥ Received input:
      {
        "count": "not a number"
      }

      âš ï¸  Validation errors:
        â€¢ count: Invalid input: expected number, received string

      ðŸ’¡ To fix: Ensure your input matches the expected schema structure and types."
    `);
  });

  it("provides detailed validation errors with schema and input", async () => {
    const complexFunction: SandboxFunction<
      { name: string; age: number; tags: string[] },
      unknown
    > = {
      description: "A function with complex input requirements",
      inputSchema: z.object({
        name: z.string().describe("The person's name"),
        age: z.number().describe("The person's age"),
        tags: z.array(z.string()).describe("Array of tags"),
      }),
      execute: async () => ({}),
    };

    const tool = createSandboxTool({
      functions: {
        complexFunction: complexFunction as SandboxFunction<unknown, unknown>,
      },
    });

    const result = await executeToolCode(
      tool,
      `return await complexFunction({ name: "Alice", age: "thirty", tags: "not-an-array" });`
    );

    expect(result.error).toBeDefined();
    expect(result.error).toMatchInlineSnapshot(`
      "âŒ Validation error in function 'complexFunction'

      ðŸ“‹ Expected schema:
      {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
          "name": {
            "description": "The person's name",
            "type": "string"
          },
          "age": {
            "description": "The person's age",
            "type": "number"
          },
          "tags": {
            "description": "Array of tags",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "name",
          "age",
          "tags"
        ],
        "additionalProperties": false
      }

      ðŸ“¥ Received input:
      {
        "name": "Alice",
        "age": "thirty",
        "tags": "not-an-array"
      }

      âš ï¸  Validation errors:
        â€¢ age: Invalid input: expected number, received string
        â€¢ tags: Invalid input: expected array, received string

      ðŸ’¡ To fix: Ensure your input matches the expected schema structure and types."
    `);
  });

  it("throws error when calling non-existent function", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(tool, "return await nonExistent({});");

    expect(result.error).toBeDefined();
    expect(result.error).toMatchInlineSnapshot(
      `"ReferenceError: nonExistent is not defined"`
    );
  });

  it("supports multiple function calls", async () => {
    const addOne: SandboxFunction<{ value: number }, number> = {
      description: "Adds 1 to a number",
      inputSchema: z.object({ value: z.number() }),
      execute: async ({ value }) => value + 1,
    };

    const double: SandboxFunction<{ value: number }, number> = {
      description: "Doubles a number",
      inputSchema: z.object({ value: z.number() }),
      execute: async ({ value }) => value * 2,
    };

    const tool = createSandboxTool({
      functions: {
        addOne: addOne as SandboxFunction<unknown, unknown>,
        double: double as SandboxFunction<unknown, unknown>,
      },
    });
    const result = await executeToolCode(
      tool,
      `
        const a = await addOne({ value: 10 });
        const b = await double({ value: 10 });
        return a + b;
      `
    );

    expect(result.output).toBe(31); // 11 + 20
    expect(result.error).toBeUndefined();
  });

  it("supports complex workflows with data processing", async () => {
    const getData: SandboxFunction<Record<string, never>, number[]> = {
      description: "Get array of numbers",
      inputSchema: z.object({}),
      execute: async () => [1, 2, 3, 4, 5],
    };

    const tool = createSandboxTool({
      functions: { getData: getData as SandboxFunction<unknown, unknown> },
    });
    const result = await executeToolCode(
      tool,
      `
        const numbers = await getData({});

        // Calculate statistics
        const sum = numbers.reduce((a, b) => a + b, 0);
        const mean = sum / numbers.length;
        const max = Math.max(...numbers);

        return { sum, mean, max, count: numbers.length };
      `
    );

    expect(result.output).toEqual({
      sum: 15,
      mean: 3,
      max: 5,
      count: 5,
    });
    expect(result.error).toBeUndefined();
  });

  it("respects timeout setting", async () => {
    const tool = createSandboxTool({ functions: {}, timeout: 100 });
    const result = await executeToolCode(
      tool,
      `
        while(true) {
          // Infinite loop
        }
      `
    );

    expect(result.error).toBeDefined();
    expect(result.error?.toLowerCase()).toContain("timed out");
  });

  it("isolates sandbox from external scope", async () => {
    const tool = createSandboxTool({ functions: {} });
    const result = await executeToolCode(
      tool,
      `
        try {
          // Try to access process (should not be available)
          return typeof process;
        } catch (e) {
          return "isolated";
        }
      `
    );

    // In vm context, global objects like 'process' are not available
    expect(result.output).toBe("undefined");
  });
});
</file>

<file path="packages/app/agent/utils/createSandboxTool.ts">
import { tool } from "ai";
import vm from "node:vm";
import { z, toJSONSchema } from "zod";

/**
 * A sandboxed function that can be called from within the VM.
 * Matches the structure returned by AI SDK's `tool` function.
 */
export interface SandboxFunction<INPUT = unknown, RESULT = unknown> {
  description: string;
  inputSchema: z.ZodType<INPUT>;
  execute: (input: INPUT) => Promise<RESULT> | RESULT;
}

/**
 * Options for creating a sandbox tool.
 */
export interface CreateSandboxToolOptions {
  /**
   * Functions that will be available to the sandboxed code.
   * The key is the function name that will be accessible in the sandbox.
   */
  functions: Record<string, SandboxFunction<unknown, unknown>>;

  /**
   * Memory limit for the context in MB. Defaults to 128MB.
   * Note: This is a soft limit and depends on V8's memory management.
   */
  memoryLimit?: number;

  /**
   * Timeout for code execution in milliseconds. Defaults to 30000ms (30 seconds).
   */
  timeout?: number;
}

/**
 * Result of executing code in the sandbox.
 */
export interface SandboxExecutionResult {
  /**
   * The return value from the executed code.
   */
  output: unknown;

  /**
   * Console output captured during execution.
   */
  logs: string[];

  /**
   * Any errors that occurred during execution.
   */
  error?: string;
}

/**
 * Formats a Zod validation error into a helpful message for the AI to understand
 * what went wrong and how to fix it.
 */
function formatValidationError(
  functionName: string,
  fn: SandboxFunction<unknown, unknown>,
  input: unknown,
  error: z.ZodError
): string {
  const lines: string[] = [];

  lines.push(`âŒ Validation error in function '${functionName}'`);
  lines.push("");
  lines.push("ðŸ“‹ Expected schema:");
  lines.push(JSON.stringify(toJSONSchema(fn.inputSchema), null, 2));
  lines.push("");
  lines.push("ðŸ“¥ Received input:");
  lines.push(JSON.stringify(input, null, 2));
  lines.push("");
  lines.push("âš ï¸  Validation errors:");

  for (const issue of error.issues) {
    const path = issue.path.length > 0 ? issue.path.join(".") : "(root)";
    lines.push(`  â€¢ ${path}: ${issue.message}`);

    if (issue.code === "invalid_type") {
      const expected = (issue as { expected?: string }).expected;
      const received = (issue as { received?: string }).received;
      if (expected && received) {
        lines.push(`    Expected: ${expected}, Received: ${received}`);
      }
    }
  }

  lines.push("");
  lines.push(
    "ðŸ’¡ To fix: Ensure your input matches the expected schema structure and types."
  );

  return lines.join("\n");
}

/**
 * Creates a tool that executes JavaScript code in an isolated VM with access
 * to specified functions. This is useful for data analysis and code execution
 * where you want to provide the agent with a safe execution environment.
 *
 * Note: This uses Node.js's vm module which provides basic sandboxing but is not
 * completely secure against determined attackers. For production use with untrusted
 * code, consider using a more robust solution like Docker containers or WebAssembly.
 *
 * @param options Configuration options including available functions
 * @returns A tool that can be used with AI SDK agents
 *
 * @example
 * ```typescript
 * const sandboxTool = createSandboxTool({
 *   functions: {
 *     fetchData: {
 *       description: "Fetch data from the database",
 *       inputSchema: z.object({ query: z.string() }),
 *       execute: async ({ query }) => {
 *         return await db.query(query);
 *       },
 *     },
 *   },
 * });
 *
 * const agent = new Agent({
 *   model: anthropic("claude-haiku-4-5"),
 *   tools: { runCode: sandboxTool },
 * });
 *
 * // The AI can write code like:
 * // const data = await fetchData({ query: "SELECT * FROM users" });
 * // return data.length;
 * ```
 */
export function createSandboxTool(options: CreateSandboxToolOptions) {
  const { functions, timeout = 30000 } = options;

  return tool({
    description: `Execute JavaScript code in a secure sandbox environment. ${
      Object.keys(functions).length > 0
        ? `Available functions: ${Object.keys(functions).join(", ")}. `
        : ""
    }The code should return a value which will be captured as output. Console logs are also captured. Functions are async and should be awaited.`,
    inputSchema: z.object({
      code: z
        .string()
        .describe(
          "The JavaScript code to execute. Use 'return' to provide output. Available functions can be called directly."
        ),
    }),
    execute: async ({ code }) => {
      const logs: string[] = [];
      let output: unknown;
      let error: string | undefined;

      try {
        // Create sandbox context with console logging
        const sandbox: Record<string, unknown> = {
          console: {
            log: (...args: unknown[]) => {
              logs.push(
                args
                  .map((arg) =>
                    typeof arg === "object" ? JSON.stringify(arg) : String(arg)
                  )
                  .join(" ")
              );
            },
            error: (...args: unknown[]) => {
              logs.push(
                "ERROR: " +
                  args
                    .map((arg) =>
                      typeof arg === "object"
                        ? JSON.stringify(arg)
                        : String(arg)
                    )
                    .join(" ")
              );
            },
          },
        };

        // Inject functions into the sandbox
        // Each function is wrapped to validate its input and handle async execution
        for (const [name, fn] of Object.entries(functions)) {
          sandbox[name] = async (input: unknown) => {
            try {
              // Validate input against the function's schema
              const validatedInput = fn.inputSchema.parse(input);
              // Execute the function
              return await Promise.resolve(fn.execute(validatedInput));
            } catch (err) {
              // Format validation errors to help the AI understand what went wrong
              if (err instanceof z.ZodError) {
                const formattedError = formatValidationError(
                  name,
                  fn,
                  input,
                  err
                );
                throw new Error(formattedError);
              }
              throw err;
            }
          };
        }

        // Wrap code in an async function so it can use await
        const wrappedCode = `
          (async function() {
            ${code}
          })()
        `;

        // Create context and execute the code with timeout
        const context = vm.createContext(sandbox);
        const script = new vm.Script(wrappedCode);

        output = await script.runInContext(context, { timeout });
      } catch (err) {
        error =
          err instanceof Error
            ? err.message
            : typeof err === "string"
              ? err
              : String(err);
        logs.push(`ERROR: ${error}`);
      }

      return {
        output,
        logs,
        error,
      };
    },
  });
}
</file>

<file path="packages/app/agent/utils/generateFunctionDocs.test.ts">
import { describe, expect, it } from "bun:test";
import { z } from "zod";
import { generateFunctionDocs } from "./generateFunctionDocs";

describe("generateFunctionDocs", () => {
  it("generates documentation for no functions", () => {
    const docs = generateFunctionDocs({});
    expect(docs).toMatchInlineSnapshot(
      `"No additional functions are available."`
    );
  });

  it("generates documentation for single function", () => {
    const functions = {
      fetchData: {
        description: "Fetches data from database",
        inputSchema: z.object({
          id: z.string().describe("The ID to fetch"),
        }),
        execute: async () => ({}),
      },
    };

    const docs = generateFunctionDocs(functions);
    expect(docs).toMatchInlineSnapshot(`
      "# Available Functions

      All functions are async and must be awaited. Call them directly from your code.

      ### fetchData(input)

      Fetches data from database

      **Input Schema:**
      \`\`\`json
      {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
          "id": {
            "description": "The ID to fetch",
            "type": "string"
          }
        },
        "required": [
          "id"
        ],
        "additionalProperties": false
      }
      \`\`\`"
    `);
  });

  it("generates documentation for multiple functions", () => {
    const functions = {
      add: {
        description: "Adds two numbers",
        inputSchema: z.object({
          a: z.number().describe("First number"),
          b: z.number().describe("Second number"),
        }),
        execute: async () => 0,
      },
      multiply: {
        description: "Multiplies two numbers",
        inputSchema: z.object({
          x: z.number().describe("First factor"),
          y: z.number().describe("Second factor"),
        }),
        execute: async () => 0,
      },
    };

    const docs = generateFunctionDocs(functions);
    expect(docs).toMatchInlineSnapshot(`
      "# Available Functions

      All functions are async and must be awaited. Call them directly from your code.

      ### add(input)

      Adds two numbers

      **Input Schema:**
      \`\`\`json
      {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
          "a": {
            "description": "First number",
            "type": "number"
          },
          "b": {
            "description": "Second number",
            "type": "number"
          }
        },
        "required": [
          "a",
          "b"
        ],
        "additionalProperties": false
      }
      \`\`\`

      ### multiply(input)

      Multiplies two numbers

      **Input Schema:**
      \`\`\`json
      {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
          "x": {
            "description": "First factor",
            "type": "number"
          },
          "y": {
            "description": "Second factor",
            "type": "number"
          }
        },
        "required": [
          "x",
          "y"
        ],
        "additionalProperties": false
      }
      \`\`\`"
    `);
  });

  it("handles functions without parameter descriptions", () => {
    const functions = {
      simple: {
        description: "A simple function",
        inputSchema: z.object({
          value: z.string(),
        }),
        execute: async () => ({}),
      },
    };

    const docs = generateFunctionDocs(functions);
    expect(docs).toMatchInlineSnapshot(`
      "# Available Functions

      All functions are async and must be awaited. Call them directly from your code.

      ### simple(input)

      A simple function

      **Input Schema:**
      \`\`\`json
      {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "type": "object",
        "properties": {
          "value": {
            "type": "string"
          }
        },
        "required": [
          "value"
        ],
        "additionalProperties": false
      }
      \`\`\`"
    `);
  });
});
</file>

<file path="packages/app/agent/utils/generateFunctionDocs.ts">
import { toJSONSchema } from "zod";
import type { SandboxFunction } from "./createSandboxTool";

/**
 * Helper function to generate documentation for available functions
 * that can be included in the agent's system prompt.
 *
 * @param functions The functions available in the sandbox
 * @returns Formatted documentation string
 */
export function generateFunctionDocs(
  functions: Record<string, SandboxFunction<unknown, unknown>>
): string {
  const entries = Object.entries(functions);
  if (entries.length === 0) {
    return "No additional functions are available.";
  }

  const docs = entries
    .map(([name, fn]) => {
      const jsonSchema = toJSONSchema(fn.inputSchema);

      return `### ${name}(input)\n\n${fn.description}\n\n**Input Schema:**\n\`\`\`json\n${JSON.stringify(jsonSchema, null, 2)}\n\`\`\``;
    })
    .join("\n\n");

  return `# Available Functions\n\nAll functions are async and must be awaited. Call them directly from your code.\n\n${docs}`;
}
</file>

<file path="packages/app/agent/utils/wrapStreamWithPromise.ts">
import type { Message } from "@ai-starter/core";
import type { SimplifiedStreamPart } from "./streamAgent";

/**
 * Wraps an async generator to collect Message items and also provide them
 * via a promise that resolves when the stream completes.
 *
 * @param stream The async generator to wrap
 * @returns Object with the wrapped stream and a promise for collected messages
 */
export function wrapStreamWithPromise(
  stream: AsyncGenerator<SimplifiedStreamPart, void, undefined>
): {
  stream: AsyncGenerator<SimplifiedStreamPart, void, undefined>;
  messages: Promise<Message[]>;
} {
  const streamedMessages: Message[] = [];
  let generator!: AsyncGenerator<SimplifiedStreamPart, void, undefined>;

  const messagesPromise = new Promise<Message[]>((resolve, reject) => {
    async function* wrappedStream(): AsyncGenerator<
      SimplifiedStreamPart,
      void,
      undefined
    > {
      try {
        for await (const chunk of stream) {
          if (chunk.type === "message") {
            streamedMessages.push(chunk.message);
          }
          yield chunk;
        }
        resolve(streamedMessages);
      } catch (error) {
        reject(error);
        throw error;
      }
    }

    generator = wrappedStream();
  });

  return {
    stream: generator,
    messages: messagesPromise,
  };
}
</file>

<file path="packages/app/agent/examples.ts">
import { Experimental_Agent as Agent, stepCountIs, tool } from "ai";
import { anthropic } from "@ai-sdk/anthropic";
import { z } from "zod";
import type { FooRepository } from "@ai-starter/core";
import {
  createSandboxTool,
  generateFunctionDocs,
  type SandboxFunction,
} from "./utils";

/**
 * Example: Creating an agent with sandbox capabilities for data analysis.
 *
 * This demonstrates how to provide an AI agent with the ability to execute
 * JavaScript code in a sandbox environment while exposing specific functions
 * for data access and manipulation.
 */

// Define the functions that will be available in the sandbox
function createDataAnalysisFunctions(fooRepo: FooRepository) {
  const fetchFooById: SandboxFunction<{ id: string }, unknown> = {
    description: "Fetch a specific foo item by ID",
    inputSchema: z.object({
      id: z.string().describe("The ID of the foo item to fetch"),
    }),
    execute: async ({ id }) => {
      const foo = await fooRepo.get(id);
      if (!foo) {
        throw new Error(`Foo with ID ${id} not found`);
      }
      return foo;
    },
  };
  const listFoos: SandboxFunction<unknown, unknown[]> = {
    description: "List all foo items",
    inputSchema: z.object({}),
    execute: async () => {
      return await fooRepo.listAll();
    },
  };

  const calculateStats: SandboxFunction<{ numbers: number[] }, unknown> = {
    description: "Calculate statistical metrics for an array of numbers",
    inputSchema: z.object({
      numbers: z.array(z.number()).describe("Array of numbers to analyze"),
    }),
    execute: async ({ numbers }) => {
      const sum = numbers.reduce((a: number, b: number) => a + b, 0);
      const mean = sum / numbers.length;
      const min = Math.min(...numbers);
      const max = Math.max(...numbers);
      return { sum, mean, min, max, count: numbers.length };
    },
  };

  return {
    fetchFooById,
    listFoos,
    calculateStats,
  } as Record<string, SandboxFunction<unknown, unknown>>;
}

/**
 * Creates an agent configured for data analysis with sandbox code execution.
 */
export function createDataAnalysisAgent(fooRepo: FooRepository) {
  const sandboxFunctions = createDataAnalysisFunctions(fooRepo);

  return new Agent({
    model: anthropic("claude-haiku-4-5"),
    system: `You are a data analysis assistant. You can help users analyze data by writing JavaScript code.

You have access to a code sandbox where you can execute JavaScript code to process and analyze data.
You can call functions directly from your code to fetch data and perform operations.

All functions are async and must be awaited. Example usage:

\`\`\`javascript
const foo = await fetchFooById({ id: "some-id" });
console.log("Got foo:", foo.name);

const stats = await calculateStats({ numbers: [1, 2, 3, 4, 5] });
return stats.mean;
\`\`\`

You can combine function calls with any JavaScript logic to analyze and transform data.
Use console.log() for debugging -- you will be able to see the logs in the output.

The return value will be shown to the user, but not to you to preserve your context window and protect sensitive information.

${generateFunctionDocs(sandboxFunctions)}}
`,
    tools: {
      runCode: createSandboxTool({
        functions: sandboxFunctions,
        timeout: 30000,
      }),
      getWeather: tool({
        description: "Get current weather for a location",
        inputSchema: z.object({
          location: z
            .string()
            .describe("The city and state, e.g. San Francisco, CA"),
        }),
        execute: async () => {
          // Simulate weather API call
          await new Promise((resolve) => setTimeout(resolve, 500));
          return {
            temperature: Math.floor(Math.random() * 30) + " degrees celsius",
          };
        },
      }),
    },
    stopWhen: stepCountIs(10),
  });
}

/**
 * Example: Simple agent without sandbox (existing behavior)
 */
export const simpleAgent = new Agent({
  model: anthropic("claude-haiku-4-5"),
  system:
    "You are a helpful assistant for an extraterrestrial weather service.",
  tools: {
    getWeather: tool({
      description: "Get Weather",
      inputSchema: z.object({
        location: z
          .string()
          .describe("The city and state, e.g. San Francisco, CA"),
      }),
      execute: async () => {
        await new Promise((resolve) => setTimeout(resolve, 2000));
        return { output: Math.floor(Math.random() * 30) + " degrees celsius" };
      },
    }),
  },
  stopWhen: stepCountIs(5),
});
</file>

<file path="packages/app/agent/index.ts">
export * from "./AiAgentService";
</file>

<file path="packages/app/core/CoreAppService.ts">
import {
  type FooRepository,
  type Foo,
  type NewFoo,
  fooValidator,
} from "@ai-starter/core";

/**
 * These are the dependencies required by the CoreAppService.
 * We inject the *ports* (interfaces), not concrete implementations.
 */
export interface Deps {
  repos: {
    foo: FooRepository;
  };
}

/**
 * This is the factory function for the CoreAppService.
 *
 * @param deps The dependencies (ports) needed by the service.
 * @returns The CoreAppService.
 */
export const CoreAppService = (deps: Deps) => {
  const { repos } = deps;

  return {
    /**
     * Gets a single Foo item by its ID.
     * @param id The UUID of the foo.
     * @returns The Foo item, or null if not found.
     */
    getFoo: async (id: string): Promise<Foo | null> => {
      // Future business logic could go here (e.g., permissions checks)
      return repos.foo.get(id);
    },

    /**
     * Validates and creates a new Foo item.
     *
     * @param data The data for the new Foo
     * @returns The newly created Foo item.
     */
    createFoo: async (name: string): Promise<Foo> => {
      const newFoo: NewFoo = {
        name,
        id: crypto.randomUUID(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      fooValidator.parse(newFoo);
      return repos.foo.create(newFoo);
    },

    /**
     * Validates and updates the name of a Foo item.
     * @param id The UUID of the foo to patch.
     * @param name The new name.
     * @returns The updated Foo item.
     */
    patchFoo: async (id: string, name: string): Promise<Foo> => {
      fooValidator.shape.name.parse(name);
      return repos.foo.patch(id, name);
    },
  };
};

/**
 * Export the type of the service for use in other layers.
 */
export type CoreAppService = ReturnType<typeof CoreAppService>;
</file>

<file path="packages/app/core/index.ts">
export * from "./CoreAppService";
</file>

<file path="packages/app/README.md">
# App Module

This package contains the main application logic, including service layers. It
does not contain any port adapters, which are located in their own packages
(e.g., `db` for database access, `ai-sdk` for LLM access). It also does not
contain deployable units; those are located in the top-level `apps/` folder.
</file>

<file path="packages/app/tsconfig.json">
{
  "extends": "../../tsconfig.base.json"
}
</file>

<file path="packages/core/ports/repositories/ConversationRepository.ts">
import type { Conversation, NewConversation } from "../../schema";

export interface ConversationRepository {
  list(): Promise<Conversation[]>;
  get(id: string): Promise<Conversation | null>;
  create(data: NewConversation): Promise<Conversation>;
  delete(id: string): Promise<void>;
}
</file>

<file path="packages/core/ports/repositories/MessageRepository.ts">
import type { Message, NewMessage } from "../../schema";

export interface MessageRepository {
  listByConversation(conversationId: string): Promise<Message[]>;
  create(data: NewMessage): Promise<Message>;
}
</file>

<file path="packages/core/schema/utils/timestamps.ts">
import { integer } from "drizzle-orm/sqlite-core";

export const timestamps = {
  createdAt: integer("created_at", { mode: "timestamp" })
    .notNull()
    .$defaultFn(() => new Date()),
  updatedAt: integer("updated_at", { mode: "timestamp" })
    .notNull()
    .$defaultFn(() => new Date())
    .$onUpdateFn(() => new Date()),
};
</file>

<file path="packages/core/schema/conversation.ts">
import { sqliteTable, text } from "drizzle-orm/sqlite-core";
import { timestamps } from "./utils/timestamps";

export const conversationSchema = sqliteTable("conversation", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  title: text("title"),
  ...timestamps,
});

export type Conversation = typeof conversationSchema.$inferSelect;
export type NewConversation = typeof conversationSchema.$inferInsert;
</file>

<file path="packages/core/validators/conversation.ts">
import { z } from "zod";

export const conversationValidator = z.object({
  id: z.uuid(),
  title: z.string().min(1).max(255).nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
});
</file>

<file path="packages/core/validators/message.ts">
import { z } from "zod";

export const messageRoleValidator = z.enum(["user", "assistant"]);

export const messageValidator = z.object({
  id: z.uuid(),
  conversationId: z.uuid(),
  role: messageRoleValidator,
  content: z.string().min(1),
  toolInvocations: z.string().nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
});
</file>

<file path="packages/core/index.ts">
export * from "./schema";
export * from "./validators";
export * from "./ports/repositories";
</file>

<file path="packages/core/README.md">
# Core Module

This package defines core data types and models. It should have no dependencies
on the rest of our code (or indeed on anything other than basic schema-building
tools like zod and drizzle).

It can contain simple business logic (e.g. zod validation).

Currently there's no testing set up here because there's no logic to test; just
schema definitions.
</file>

<file path="packages/core/tsconfig.json">
{
  "extends": "../../tsconfig.base.json"
}
</file>

<file path="packages/db/repositories/ConversationRepository.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { DrizzleConversationRepository } from "./ConversationRepository";
import type { DB } from "../db";
import { testDB } from "../test-utils/db";
import { mockConversations } from "../test-utils";

describe("DrizzleConversationRepository", () => {
  let db: DB;
  let repository: ReturnType<typeof DrizzleConversationRepository>;

  beforeEach(async () => {
    db = await testDB();
    repository = DrizzleConversationRepository({ db });
  });

  describe("list", () => {
    it("should return all conversations ordered by most recent first", async () => {
      const result = await repository.list();

      expect(result).toHaveLength(2);
      // Results should be ordered by createdAt desc
      expect(result[0]?.id).toBe(mockConversations[0]?.id);
    });

    it("should return empty array when no conversations exist", async () => {
      const freshDb = await testDB({ seed: false });
      const freshRepo = DrizzleConversationRepository({ db: freshDb });

      const result = await freshRepo.list();

      expect(result).toHaveLength(0);
    });
  });

  describe("get", () => {
    it("should return null when conversation does not exist", async () => {
      const result = await repository.get(
        "00000000-0000-4000-8000-999999999999"
      );
      expect(result).toBeNull();
    });

    it("should return conversation when it exists", async () => {
      const result = await repository.get(
        "00000000-0000-4000-8000-000000000001"
      );

      expect(result).not.toBeNull();
      expect(result?.id).toBe("00000000-0000-4000-8000-000000000001");
      expect(result?.title).toBe("First Conversation");
    });
  });

  describe("create", () => {
    it("should create a new conversation with a title", async () => {
      const now = new Date();
      now.setMilliseconds(0); // SQLite precision fix
      const conversation = await repository.create({
        id: "00000000-0000-4000-8000-000000000099",
        title: "New Conversation",
        createdAt: now,
        updatedAt: now,
      });

      const result = await repository.get(conversation.id);

      expect(result).not.toBeNull();
      expect(result?.id).toBe("00000000-0000-4000-8000-000000000099");
      expect(result?.title).toBe("New Conversation");
      expect(result?.createdAt).toEqual(now);
    });

    it("should create a new conversation without a title", async () => {
      const now = new Date();
      now.setMilliseconds(0);
      const conversation = await repository.create({
        id: "00000000-0000-4000-8000-000000000098",
        title: null,
        createdAt: now,
        updatedAt: now,
      });

      const result = await repository.get(conversation.id);

      expect(result).not.toBeNull();
      expect(result?.title).toBeNull();
    });

    it("should auto-generate ID and timestamps for a new conversation", async () => {
      const conversation = await repository.create({
        title: "Auto ID",
      });

      const result = await repository.get(conversation.id);

      expect(result).not.toBeNull();
      expect(result?.id).toBeDefined();
      expect(result?.createdAt).toBeDefined();
      expect(result?.updatedAt).toBeDefined();
    });
  });

  describe("delete", () => {
    it("should delete a conversation", async () => {
      await repository.delete("00000000-0000-4000-8000-000000000001");

      const result = await repository.get(
        "00000000-0000-4000-8000-000000000001"
      );
      expect(result).toBeNull();
    });

    it("should not throw an error when deleting non-existent conversation", async () => {
      await repository.delete("00000000-0000-4000-8000-999999999999");
      // If we reach here, the delete succeeded without throwing
      expect(true).toBe(true);
    });
  });
});
</file>

<file path="packages/db/repositories/ConversationRepository.ts">
import {
  conversationSchema,
  type ConversationRepository,
} from "@ai-starter/core";
import type { DB } from "../db";
import { eq } from "drizzle-orm";
import { badImplementation } from "@hapi/boom";

interface Deps {
  db: DB;
}

export const DrizzleConversationRepository = ({
  db,
}: Deps): ConversationRepository => ({
  async list() {
    const results = await db.query.conversationSchema.findMany({
      orderBy: (conversation, { desc }) => [desc(conversation.createdAt)],
    });
    return results;
  },

  async get(id: string) {
    const result = await db.query.conversationSchema.findFirst({
      where: eq(conversationSchema.id, id),
    });
    return result ?? null;
  },

  async create(data) {
    const [result] = await db
      .insert(conversationSchema)
      .values(data)
      .returning();
    if (!result) throw badImplementation("Failed to create Conversation");
    return result;
  },

  async delete(id: string) {
    await db.delete(conversationSchema).where(eq(conversationSchema.id, id));
  },
});
</file>

<file path="packages/db/repositories/MessageRepository.ts">
import { messageSchema, type MessageRepository } from "@ai-starter/core";
import type { DB } from "../db";
import { eq } from "drizzle-orm";
import { badImplementation } from "@hapi/boom";

interface Deps {
  db: DB;
}

export const DrizzleMessageRepository = ({ db }: Deps): MessageRepository => ({
  async listByConversation(conversationId: string) {
    const results = await db.query.messageSchema.findMany({
      where: eq(messageSchema.conversationId, conversationId),
      orderBy: (message, { asc }) => [asc(message.createdAt)],
    });
    return results;
  },

  async create(data) {
    const [result] = await db.insert(messageSchema).values(data).returning();
    if (!result) throw badImplementation("Failed to create Message");
    return result;
  },
});
</file>

<file path="packages/db/test-utils/seed/all.ts">
import type { DB } from "../../db";
import { doSeedConversations } from "./conversation";
import { doSeedFoos } from "./foo";
import { doSeedMessages } from "./message";

export async function doSeedAll(db: DB) {
  await doSeedFoos(db);
  await doSeedConversations(db);
  await doSeedMessages(db);
}
</file>

<file path="packages/db/test-utils/seed/conversation.ts">
import { conversationSchema } from "@ai-starter/core";
import type { DB } from "../../db";
import { seedNow } from "./foo";

export const mockConversations = [
  {
    id: "00000000-0000-4000-8000-000000000001",
    title: "First Conversation",
    createdAt: seedNow,
    updatedAt: seedNow,
  },
  {
    id: "00000000-0000-4000-8000-000000000002",
    title: null,
    createdAt: seedNow,
    updatedAt: seedNow,
  },
] as const;

export const doSeedConversations = (db: DB) => {
  return db.insert(conversationSchema).values([...mockConversations]);
};
</file>

<file path="packages/db/README.md">
# DB Module

This package defines database connection utilities, data-access tools
(implementations of repository interfaces defined in the core package), and
utilities for setting up and seeding the database for tests.

It does not contain the database schema itself; that lives in the core package,
since it's part of the core domain model.
</file>

<file path="packages/db/tsconfig.json">
{
  "extends": "../../tsconfig.base.json"
}
</file>

<file path="tests/api.test.ts">
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import * as fs from "node:fs";
import { treaty } from "@elysiajs/eden";
import { getApp, type App } from "@ai-starter/api";
import { getContext } from "@ai-starter/api/context";
import { setupDB } from "./utils/db";

describe("API e2e", () => {
  let tmpDir: string;
  let client: ReturnType<typeof treaty<App>>;

  beforeEach(async () => {
    const { tmpDir: dir, dbPath } = await setupDB("api-test-");
    tmpDir = dir;

    const ctx = getContext(`file:${dbPath}`);
    const app = getApp(ctx);
    client = treaty<App>(app);
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("should create, get, patch, and get again a foo", async () => {
    // 1. Create a foo
    const createResponse = await client.foos.post({ name: "Initial Foo" });

    expect(createResponse.status).toBe(201);
    expect(createResponse.data).toBeDefined();
    const created = createResponse.data!;
    expect(created.name).toBe("Initial Foo");
    expect(created.id).toBeDefined();
    const fooId = created.id;

    // 2. Get the foo
    const getResponse = await client.foos({ id: fooId }).get();

    expect(getResponse.status).toBe(200);
    expect(getResponse.data).toBeDefined();
    const retrieved = getResponse.data!;
    expect(retrieved).toEqual(created);

    // 3. Patch the foo
    const patchResponse = await client.foos({ id: fooId }).patch({
      name: "Updated Foo",
    });

    expect(patchResponse.status).toBe(200);
    expect(patchResponse.data).toBeDefined();
    const patched = patchResponse.data!;
    expect(patched.name).toBe("Updated Foo");
    expect(patched.id).toBe(fooId);

    // 4. Get the foo again to verify the update
    const finalGetResponse = await client.foos({ id: fooId }).get();

    expect(finalGetResponse.status).toBe(200);
    expect(finalGetResponse.data).toBeDefined();
    const final = finalGetResponse.data!;
    expect(final.name).toBe("Updated Foo");
    expect(final.id).toBe(fooId);
  });
});
</file>

<file path="tests/tsconfig.json">
{
  "extends": "../tsconfig.base.json"
}
</file>

<file path=".prettierignore">
# Dependencies
node_modules
bun.lockb
bun.lock

# Build outputs
dist
build
.next
out

# Generated files
*.generated.*

# Misc
.env
.env.*
!.env.example
coverage
*.log
</file>

<file path=".prettierrc">
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": false,
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "always",
  "endOfLine": "lf"
}
</file>

<file path="eslint.config.mjs">
import eslint from "@eslint/js";
import { defineConfig } from "eslint/config";
import tseslint from "typescript-eslint";

export default defineConfig(
  eslint.configs.recommended,
  tseslint.configs.strict,
  tseslint.configs.stylistic,
  {
    rules: {
      "@typescript-eslint/no-unused-vars": [
        "error",
        {
          args: "all",
          argsIgnorePattern: "^_",
          caughtErrors: "all",
          caughtErrorsIgnorePattern: "^_",
          destructuredArrayIgnorePattern: "^_",
          varsIgnorePattern: "^_",
          ignoreRestSiblings: true,
        },
      ],
    },
  },
  {
    files: ["**/*.test.ts"],
    rules: {
      "@typescript-eslint/no-non-null-assertion": "off",
    },
  }
);
</file>

<file path="tsconfig.base.json">
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false
  }
}
</file>

<file path="apps/cli/commands/chat.ts">
import { command } from "cleye";
import { getContext } from "../utils/app";
import { FLAGS } from "../utils/flags";
import { createInterface } from "readline";
import {
  renderMessages,
  renderMessage,
  renderTextDelta,
  startTextStream,
  endTextStream,
} from "../utils/render";
import chalk from "chalk";

export const chat = command(
  {
    name: "chat",
    help: {
      description: "Chat with the AI agent",
      examples: [
        "bun cli chat # start a new interactive conversation",
        'bun cli chat --conversation-id "1234" --message "Hello, how are you?" # send a message to an existing conversation',
      ],
    },
    flags: {
      ...FLAGS,
      conversationId: {
        type: String,
        alias: "c",
        description: "The ID of the conversation to continue",
        required: false,
      },
      message: {
        type: String,
        alias: "m",
        description: "The message to send to the AI agent",
        required: false,
      },
    },
    parameters: ["[conversation id]", "[message]"],
  },
  async (argv) => {
    const { agent } = await getContext(argv.flags.database);
    let conversationId = argv.flags.conversationId;

    if (!conversationId) {
      const convo = await agent.createConversation();
      conversationId = convo.id;
      console.log(
        chalk.bold.cyan("Started new conversation with ID:"),
        conversationId
      );
    } else {
      // Load and render previous messages
      const previousMessages =
        await agent.getConversationMessages(conversationId);
      if (previousMessages.length > 0) {
        renderMessages(previousMessages);
      }
    }

    let message = argv.flags.message;
    if (!message) {
      // prompt the user interactively
      const readline = createInterface({
        input: process.stdin,
        output: process.stdout,
      });

      message = await new Promise<string>((resolve) => {
        readline.question(
          chalk.bold.green("Enter your message: "),
          (input: string) => {
            readline.close();
            resolve(input);
          }
        );
      });
    }

    const { stream } = await agent.sendMessage(conversationId, message);

    let textStreamStarted = false;

    // Stream and render content as it arrives
    for await (const chunk of stream) {
      if (chunk.type === "text-delta") {
        // Start text stream if not already started
        if (!textStreamStarted) {
          startTextStream("assistant");
          textStreamStarted = true;
        }
        renderTextDelta(chunk.delta);
      } else if (chunk.type === "message") {
        // End text stream if it was started
        if (textStreamStarted) {
          endTextStream();
          textStreamStarted = false;
        }
        // Render complete messages (tool calls, tool results)
        // skip text parts as they were already streamed
        renderMessage(chunk.message, { skipTextParts: true });
      }
    }

    // End text stream if it's still open
    if (textStreamStarted) {
      endTextStream();
    }
  }
);
</file>

<file path="apps/cli/index.ts">
#!/usr/bin/env bun
import { cli } from "cleye";
import { addFoo } from "./commands/add-foo";
import { getFoo } from "./commands/get-foo";
import { patchFoo } from "./commands/patch-foo";
import { chat } from "./commands/chat";

const argv = cli({
  name: "ai-starter",
  version: "0.0.1",
  commands: [addFoo, getFoo, patchFoo, chat],
});

if (!argv.command) {
  argv.showHelp();
}
</file>

<file path="packages/app/agent/utils/index.ts">
export { streamAgent, type SimplifiedStreamPart } from "./streamAgent";
export { wrapStreamWithPromise } from "./wrapStreamWithPromise";
export {
  createSandboxTool,
  type SandboxFunction,
  type CreateSandboxToolOptions,
  type SandboxExecutionResult,
} from "./createSandboxTool";
export { generateFunctionDocs } from "./generateFunctionDocs";
</file>

<file path="packages/app/agent/utils/streamAgent.ts">
import type { Experimental_Agent as Agent, ToolSet } from "ai";
import type { ModelMessage } from "ai";
import type { Message, NewMessage } from "@ai-starter/core";

/**
 * Simplified stream part types that we actually care about
 */
export type SimplifiedStreamPart =
  | { type: "text-delta"; delta: string }
  | { type: "message"; message: Message };

export interface StreamAgentProps {
  agent: Agent<ToolSet>;
  conversationId: string;
  messages: ModelMessage[];
  onCompleteMessage: (newMessage: NewMessage) => Promise<Message>;
}

/**
 * Wrapper around agent.stream that simplifies the stream parts to just
 * text-delta and message types, calling onCompleteMessage when
 * a complete message (text, tool-call, or tool-result) is ready.
 */
export async function* streamAgent(
  props: StreamAgentProps
): AsyncGenerator<SimplifiedStreamPart, void, undefined> {
  const { agent, conversationId, messages, onCompleteMessage } = props;

  const agentStream = agent.stream({ messages });
  let accumulatedText = "";

  for await (const chunk of agentStream.fullStream) {
    switch (chunk.type) {
      // Handle text deltas
      case "text-delta":
        accumulatedText += chunk.text;
        yield { type: "text-delta", delta: chunk.text };
        break;

      case "text-end": {
        if (!accumulatedText) continue;
        const newMessage: NewMessage = {
          conversationId,
          role: "assistant",
          content: [{ type: "text", text: accumulatedText }],
        };
        const persistedMessage = await onCompleteMessage(newMessage);
        yield { type: "message", message: persistedMessage };
        accumulatedText = "";
        break;
      }

      // Handle tool calls
      case "tool-call": {
        const newMessage: NewMessage = {
          conversationId,
          role: "assistant",
          content: [
            {
              type: "tool-call",
              toolCallId: chunk.toolCallId,
              toolName: chunk.toolName,
              input: chunk.input,
            },
          ],
        };
        const persistedMessage = await onCompleteMessage(newMessage);
        yield { type: "message", message: persistedMessage };
        break;
      }

      // Handle tool results
      case "tool-result": {
        const newMessage: NewMessage = {
          conversationId,
          role: "tool",
          content: [
            {
              type: "tool-result",
              toolCallId: chunk.toolCallId,
              toolName: chunk.toolName,
              output: { type: "json", value: chunk.output },
            },
          ],
        };
        const persistedMessage = await onCompleteMessage(newMessage);
        yield { type: "message", message: persistedMessage };
        break;
      }

      // Ignore events we don't need to handle
      case "start":
      case "finish":
      case "text-start":
      case "start-step":
      case "finish-step":
      case "tool-input-start":
      case "tool-input-delta":
      case "tool-input-end":
      case "tool-error":
      case "abort":
      case "error":
        break;

      // Warn about unexpected chunk types
      case "file":
      case "source":
      case "raw":
      case "reasoning-start":
      case "reasoning-delta":
      case "reasoning-end":
      default:
        console.warn("Unhandled chunk type:", chunk.type);
        break;
    }
  }

  // Warn if we have leftover text (shouldn't happen)
  if (accumulatedText) {
    console.warn("Unexpected remaining text after stream end");
  }
}
</file>

<file path="packages/app/agent/AiAgentService.test.ts">
import { describe, test, expect, beforeEach } from "bun:test";
import { AiAgentService } from "./AiAgentService";
import { CoreAppService } from "../core/CoreAppService";
import { testDB } from "@ai-starter/db/test-utils";
import { getRepos, type DB } from "@ai-starter/db";
import type { Message } from "@ai-starter/core";
import { createDataAnalysisAgent } from "./examples";

describe("AiAgentService.sendMessage - stream execution test", () => {
  let db: DB;
  let repos: ReturnType<typeof getRepos>;
  let service: ReturnType<typeof AiAgentService>;

  beforeEach(async () => {
    db = await testDB({ seed: false });
    repos = getRepos(db);
    const coreService = CoreAppService({ repos });
    service = AiAgentService({
      repos,
      coreService,
      agent: createDataAnalysisAgent(repos.foo),
    });
  });

  test(
    "should not execute the agent stream twice",
    async () => {
      // Create a conversation
      const conversation = await service.createConversation("Test");
      const conversationId = conversation.id;

      // Track what comes through the stream
      const streamedTextDeltas: string[] = [];
      const streamedMessages: Message[] = [];

      const { stream, messages: promisedMessages } = await service.sendMessage(
        conversationId,
        "What's the weather in London?"
      );

      // Consume the stream
      for await (const chunk of stream) {
        if (chunk.type === "text-delta") {
          streamedTextDeltas.push(chunk.delta);
        } else if (chunk.type === "message") {
          streamedMessages.push(chunk.message);
        }
      }

      const promiseMessages = await promisedMessages;

      // Get all persisted messages AFTER the promise
      const persistedAfterPromise =
        await repos.message.listByConversation(conversationId);

      // Count user messages - there should only be ONE
      const userMessages = persistedAfterPromise.filter(
        (m) => m.role === "user"
      );

      expect(userMessages.length).toBe(1);
      const persistedWithoutUser = persistedAfterPromise.slice(1);
      // streamed, promised, and persisted messages should all match
      expect(persistedWithoutUser).toEqual(promiseMessages);
      expect(promiseMessages).toEqual(streamedMessages);
    },
    // TODO: mock the llm to make this test faster
    { timeout: 10000 }
  );
});
</file>

<file path="packages/app/agent/AiAgentService.ts">
import {
  type ConversationRepository,
  type MessageRepository,
  type Conversation,
  type Message,
  type NewConversation,
  type NewMessage,
  type FooRepository,
} from "@ai-starter/core";
import type { CoreAppService } from "../core/CoreAppService";
import { type ModelMessage } from "ai";

import { Experimental_Agent as Agent } from "ai";
import {
  streamAgent,
  wrapStreamWithPromise,
  type SimplifiedStreamPart,
} from "./utils";

/**
 * These are the dependencies required by the AiAgentService.
 * We inject the *ports* (interfaces), not concrete implementations.
 */
export interface AiAgentServiceDeps {
  repos: {
    conversation: ConversationRepository;
    message: MessageRepository;
    foo: FooRepository;
  };
  coreService: CoreAppService;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  agent: Agent<any>;
}

/**
 * This is the factory function for the AiAgentService.
 *
 * @param deps The dependencies (ports) needed by the service.
 * @returns The AiAgentService.
 */
export const AiAgentService = (deps: AiAgentServiceDeps) => {
  const { repos, agent } = deps;

  return {
    /**
     * Lists all conversations, ordered by most recent first.
     * @returns Array of all conversations
     */
    listConversations: async (): Promise<Conversation[]> => {
      return repos.conversation.list();
    },

    /**
     * Gets all messages for a specific conversation, ordered chronologically.
     * @param conversationId The UUID of the conversation
     * @returns Array of messages in the conversation
     */
    getConversationMessages: async (
      conversationId: string
    ): Promise<Message[]> => {
      return repos.message.listByConversation(conversationId);
    },

    /**
     * Creates a new conversation.
     * @param title Optional title for the conversation
     * @returns The newly created conversation
     */
    createConversation: async (title?: string): Promise<Conversation> => {
      const newConversation: NewConversation = {
        title: title ?? null,
      };

      return repos.conversation.create(newConversation);
    },

    /**
     * Sends a message to the agent and persists both the user message and agent response.
     * Returns a stream that yields text deltas and complete messages (tool calls/results)
     * as they're generated, and a promise that resolves to all new messages once complete.
     *
     * @param conversationId The UUID of the conversation
     * @param message The user's message content
     * @returns Object containing an async generator for streaming and a promise for all new messages
     */
    sendMessage: async (
      conversationId: string,
      message: string
    ): Promise<{
      stream: AsyncGenerator<SimplifiedStreamPart, void, undefined>;
      messages: Promise<Message[]>;
    }> => {
      // Verify conversation exists
      const conversation = await repos.conversation.get(conversationId);
      if (!conversation) {
        throw new Error(`Conversation ${conversationId} not found`);
      }

      // Get existing messages to build context
      const existingMessages: (NewMessage | Message)[] =
        await repos.message.listByConversation(conversationId);

      const userMessage: NewMessage = {
        conversationId,
        role: "user",
        content: [{ type: "text", text: message }],
      };

      // Persist the user message
      await repos.message.create(userMessage);

      // Add the new user message to context
      existingMessages.push(userMessage);

      // Stream agent responses with callback for persistence
      const stream = streamAgent({
        agent,
        conversationId,
        // assertion necessary because our type isn't discriminated by `role`
        messages: existingMessages as ModelMessage[],
        onCompleteMessage: (newMessage: NewMessage) =>
          repos.message.create(newMessage),
      });

      // Wrap the stream to collect messages and provide a promise
      return wrapStreamWithPromise(stream);
    },
  };
};

/**
 * Export the type of the service for use in other layers.
 */
export type AiAgentService = ReturnType<typeof AiAgentService>;
</file>

<file path="packages/app/index.ts">
export * from "./core";
export * from "./agent";
</file>

<file path="packages/app/package.json">
{
  "name": "@ai-starter/app",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "devDependencies": {
    "@ai-starter/db": "workspace:*",
    "@types/bun": "^1.3.2"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-sdk/anthropic": "^2.0.44",
    "@ai-starter/core": "workspace:*",
    "@libsql/client": "^0.15.15",
    "ai": "^5.0.92",
    "drizzle-orm": "^0.44.7",
    "zod": "^4.1.12"
  }
}
</file>

<file path="packages/core/ports/repositories/index.ts">
export * from "./FooRepository";
export * from "./ConversationRepository";
export * from "./MessageRepository";
</file>

<file path="packages/core/schema/foo.ts">
import { sqliteTable, text } from "drizzle-orm/sqlite-core";
import { timestamps } from "./utils/timestamps";

export const fooSchema = sqliteTable("foo", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  name: text("name").notNull(),
  ...timestamps,
});

export type Foo = typeof fooSchema.$inferSelect;
export type NewFoo = typeof fooSchema.$inferInsert;
</file>

<file path="packages/core/schema/index.ts">
/**
 * Schema definitions describe the shape of our data _at rest_. They are complementary
 * to the validators in ../validators/index.ts, which describe the shape
 * of our data _in motion_.
 */

export * from "./foo";
export * from "./conversation";
export * from "./message";
</file>

<file path="packages/core/schema/message.ts">
import { sqliteTable, text } from "drizzle-orm/sqlite-core";
import { timestamps } from "./utils/timestamps";
import { conversationSchema } from "./conversation";

export const messageSchema = sqliteTable("message", {
  id: text("id")
    .primaryKey()
    .$defaultFn(() => crypto.randomUUID()),
  conversationId: text("conversation_id")
    .notNull()
    .references(() => conversationSchema.id, { onDelete: "cascade" }),
  role: text("role", { enum: ["user", "assistant", "tool"] }).notNull(),
  content: text("content", { mode: "json" }).notNull().$type<MessageContent>(),
  ...timestamps,
});

// Message content types aligned with AI SDK's ModelMessage
export type MessageContent = MessagePart[];

export type MessagePart = TextPart | ToolCallPart | ToolResultPart;

export interface TextPart {
  type: "text";
  text: string;
}

export interface ToolCallPart {
  type: "tool-call";
  toolCallId: string;
  toolName: string;
  // N.B. this diverges from documentation but aligns with implementation
  input: unknown;
}

export interface ToolResultPart {
  type: "tool-result";
  toolCallId: string;
  toolName: string;
  output: ToolResultOutput;
}

export type ToolResultOutput =
  | { type: "text"; value: string }
  | { type: "json"; value: unknown }
  | { type: "error-text"; value: string }
  | { type: "error-json"; value: unknown }
  | {
      type: "content";
      value: (
        | {
            type: "text";

            /**
          Text content.
            */
            text: string;
          }
        | {
            type: "media";

            /**
          Base-64 encoded media data.
            */
            data: string;

            /**
          IANA media type.
          @see https://www.iana.org/assignments/media-types/media-types.xhtml
            */
            mediaType: string;
          }
      )[];
    };

export type Message = typeof messageSchema.$inferSelect;
export type NewMessage = typeof messageSchema.$inferInsert;
</file>

<file path="packages/core/validators/foo.ts">
import { z } from "zod";

export const fooValidator = z.object({
  id: z.uuid(),
  name: z.string().min(3),
  createdAt: z.date().min(new Date(2025, 1, 1)),
});
</file>

<file path="packages/core/validators/index.ts">
/**
 * Validators describe the shape of our data _in motion_. They are complementary
 * to the schema definitions in ../schema/index.ts, which describe the shape
 * of our data _at rest_.
 *
 * One day we might unify with drizzle-zod
 */

export * from "./foo";
export * from "./conversation";
export * from "./message";
</file>

<file path="packages/core/package.json">
{
  "name": "@ai-starter/core",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5",
    "drizzle-orm": "^0.44.7"
  },
  "dependencies": {
    "zod": "^4.1.12"
  }
}
</file>

<file path="packages/db/repositories/MessageRepository.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { DrizzleMessageRepository } from "./MessageRepository";
import type { DB } from "../db";
import { testDB } from "../test-utils/db";
import { mockConversations } from "../test-utils";

describe("DrizzleMessageRepository", () => {
  let db: DB;
  let repository: ReturnType<typeof DrizzleMessageRepository>;

  beforeEach(async () => {
    db = await testDB();
    repository = DrizzleMessageRepository({ db });
  });

  describe("listByConversation", () => {
    it("should return all messages for a conversation ordered chronologically", async () => {
      const result = await repository.listByConversation(
        mockConversations[0].id
      );

      expect(result).toHaveLength(4);
      expect(result[0]?.role).toBe("user");
      expect(result[0]?.content).toEqual([
        { type: "text", text: "Hello, how are you?" },
      ]);
      expect(result[1]?.role).toBe("assistant");
      expect(result[1]?.content).toEqual([
        { type: "text", text: "I'm doing well, thank you!" },
      ]);
      expect(result[2]?.role).toBe("assistant");
      expect(Array.isArray(result[2]?.content)).toBe(true);
      expect(result[3]?.role).toBe("tool");
      expect(Array.isArray(result[3]?.content)).toBe(true);
    });

    it("should return empty array when conversation has no messages", async () => {
      const result = await repository.listByConversation(
        mockConversations[1].id
      );

      expect(result).toHaveLength(0);
    });
  });

  describe("create", () => {
    it("should create a new message", async () => {
      const now = new Date();
      now.setMilliseconds(0); // SQLite precision fix
      await repository.create({
        id: "00000000-0000-4000-8000-000000000099",
        conversationId: mockConversations[1].id,
        role: "user",
        content: [{ type: "text", text: "New message" }],
        createdAt: now,
        updatedAt: now,
      });

      const result = await repository.listByConversation(
        mockConversations[1].id
      );

      expect(result).toBeArrayOfSize(1);
      expect(result[0]!.id).toBe("00000000-0000-4000-8000-000000000099");
      expect(result[0]!.content).toEqual([
        { type: "text", text: "New message" },
      ]);
      expect(result[0]!.role).toBe("user");
    });

    it("should create a message with tool calls", async () => {
      const now = new Date();
      now.setMilliseconds(0);
      const content = [
        {
          type: "tool-call" as const,
          toolName: "getFoo",
          toolCallId: "call-1",
          input: { id: "foo-1" },
        },
      ];
      await repository.create({
        id: "00000000-0000-4000-8000-000000000098",
        conversationId: mockConversations[1].id,
        role: "assistant",
        content,
        createdAt: now,
        updatedAt: now,
      });

      const result = await repository.listByConversation(
        mockConversations[1].id
      );

      expect(result).toBeArrayOfSize(1);
      expect(result[0]!.id).toBe("00000000-0000-4000-8000-000000000098");
      expect(result[0]!.role).toBe("assistant");
      expect(result[0]!.content).toEqual(content);
    });

    it("should auto-generate ID and timestamps for a new message", async () => {
      const message = await repository.create({
        conversationId: mockConversations[1].id,
        role: "user",
        content: [{ type: "text", text: "Auto ID message" }],
      });

      const result = await repository.listByConversation(
        mockConversations[1].id
      );

      expect(result).toBeArrayOfSize(1);
      expect(result[0]?.id).toEqual(message.id);
      expect(result[0]?.createdAt).toBeDefined();
      expect(result[0]?.updatedAt).toBeDefined();
    });
  });
});
</file>

<file path="packages/db/test-utils/seed/foo.ts">
import { fooSchema } from "@ai-starter/core";
import type { DB } from "../../db";

export const seedNow = new Date("2024-01-01T00:00:00.000Z");

export const mockFoos = [
  {
    id: "foo-1",
    name: "First Foo",
    createdAt: seedNow,
    updatedAt: seedNow,
  },
  {
    id: "foo-2",
    name: "Second Foo",
    createdAt: seedNow,
    updatedAt: seedNow,
  },
] as const;

export const doSeedFoos = (db: DB) => {
  return db.insert(fooSchema).values([...mockFoos]);
};
</file>

<file path="packages/db/test-utils/seed/index.ts">
export * from "./foo";
export * from "./conversation";
export * from "./message";
</file>

<file path="packages/db/test-utils/seed/message.ts">
import { messageSchema, type Message } from "@ai-starter/core";
import type { DB } from "../../db";
import { seedNow } from "./foo";
import { mockConversations } from "./conversation";

export const mockMessages = [
  {
    id: "00000000-0000-4000-8000-000000000011",
    conversationId: mockConversations[0].id,
    role: "user" as const,
    content: [{ type: "text", text: "Hello, how are you?" }],
    createdAt: seedNow,
    updatedAt: seedNow,
  },
  {
    id: "00000000-0000-4000-8000-000000000012",
    conversationId: mockConversations[0].id,
    role: "assistant" as const,
    content: [{ type: "text", text: "I'm doing well, thank you!" }],
    createdAt: seedNow,
    updatedAt: seedNow,
  },
  {
    id: "00000000-0000-4000-8000-000000000013",
    conversationId: mockConversations[0].id,
    role: "assistant" as const,
    content: [
      {
        type: "tool-call" as const,
        toolCallId: "call-2",
        toolName: "getWeather",
        input: { location: "New York" },
      },
    ],
    createdAt: seedNow,
    updatedAt: seedNow,
  },
  {
    id: "00000000-0000-4000-8000-000000000014",
    conversationId: mockConversations[0].id,
    role: "tool" as const,
    content: [
      {
        type: "tool-result" as const,
        toolCallId: "call-2",
        toolName: "getWeather",
        output: { type: "text" as const, value: "72Â°F and sunny" },
      },
    ],
    createdAt: seedNow,
    updatedAt: seedNow,
  },
] as const satisfies Message[];

export const doSeedMessages = (db: DB) => {
  return db.insert(messageSchema).values([...mockMessages]);
};
</file>

<file path="packages/db/test-utils/index.ts">
export * from "./db";
export * from "./seed";
</file>

<file path="packages/db/index.ts">
export * from "./repositories";
export * from "./db";
</file>

<file path="packages/db/package.json">
{
  "name": "@ai-starter/db",
  "version": "0.0.1",
  "module": "index.ts",
  "type": "module",
  "devDependencies": {
    "@types/bun": "^1.3.2"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "dependencies": {
    "@ai-starter/core": "workspace:*",
    "@hapi/boom": "^10.0.1",
    "@libsql/client": "^0.15.15",
    "drizzle-orm": "^0.44.7"
  }
}
</file>

<file path="tests/utils/db.ts">
import fs from "fs";
import os from "os";
import path from "path";
import { getDB, migrateDB } from "@ai-starter/db";

export const setupDB = async (prefix: string) => {
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), prefix));
  const dbPath = path.join(tmpDir, "test.db");
  const db = getDB(`file:${dbPath}`);
  await migrateDB(db);
  return { db, tmpDir, dbPath };
};
</file>

<file path="tests/package.json">
{
  "name": "tests",
  "type": "module",
  "private": true,
  "dependencies": {
    "@ai-starter/api": "workspace:*",
    "@ai-starter/core": "workspace:*",
    "@ai-starter/db": "workspace:*",
    "@elysiajs/eden": "^1.4.4",
    "elysia": "^1.1.28"
  },
  "devDependencies": {
    "@types/bun": "latest"
  }
}
</file>

<file path=".gitignore">
# dependencies (bun install)
node_modules

# output
out
dist
*.tgz

# code coverage
coverage
*.lcov

# logs
logs
_.log
report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# caches
.eslintcache
.cache
*.tsbuildinfo

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

*.db
</file>

<file path="AGENTS.md">
# ai-starter

## Commands

- `bun test` - Run all tests
- `bun test path/to/file.test.ts` - Run a single test file
- `bun test -t "test name pattern"` - Run tests matching name pattern
- `bun test --coverage` - Run tests with coverage report
- `bun run typecheck` - Type-check all packages
- `bun run lint` - Check code style with ESLint and Prettier
- `bun lint:fix` - Auto-fix linting issues and format code
- `bun check` - Run all checks (tests, typecheck, lint)

## Development Workflow

- For ALL new pieces of work, always create a new branch off `main` first.
- Before you write any new code, think carefully about the code architecture.
- Always follow test-driven-development with a red-green-refactor cycle.
- Commit often with small, atomic changes.
- Always format your code with `bun lint:fix` before committing.
- Before stopping work, always make sure `bun check` passes.
- When you have finished work and `bun check` passes, you MUST ALWAYS open a new PR.
- After creating a PR, you should always wait for the CI status checks to be reported. Once they are reported as passing, you can stop working. If they fail to pass, you should always try to fix the failures (follow the normal development cycle for this, with small, focussed commits).
- Never output summaries or reports to a file unless asked to. You can report to me in your responses, but it's unhelpful to include those transient details in the codebase.

## Code Style

**Types & Functions:**

- Always use explicit types. Never use `any` -- use generic types or `unknown` if necessary.
- Don't annotate function return types -- rely on type inference.
- Prefer stateless functions over classes.
- Prefix unused variables with underscore (e.g., `_unusedParam`).

**Imports:**

- Use `type` imports for type-only imports: `import type { Foo } from "bar";`
- Group imports: external packages first, then internal packages (e.g., `@ai-starter/*`), then relative imports.

**Dependency Injection:**

- Use curried "XXXDeps" parameter pattern:
  ```ts
  export interface GetFooDeps {
    repo: FooRepository;
  }
  export function getFoo(deps: GetFooDeps) {
    return async function (props: GetFooProps) {
      return deps.repo.getFooById(props.id);
    };
  }
  ```

**File Organization:**

- Keep only one meaningful export per file. Co-locate tightly-coupled type definitions.
- Co-locate tests with code (`.test.ts` alongside `.ts`). Only e2e tests go in root `tests/` folder.

**Architecture:**

- Follow hexagonal architecture with strict dependency direction:
  - `packages/core`: Domain models and interfaces. No external dependencies.
  - `packages/app`: Application services. Depends on `core` only.
  - `packages/db`, apps in `apps/*`: Adapters. Depend on `core` and `app` but not on each other.

**Error Handling:**

- Use `@hapi/boom` for HTTP errors (e.g., `notFound()`, `badImplementation()`).

**Testing:**

- Use common test utilities from `@ai-starter/db/test-utils` for consistency.
- Review coverage with `bun test --coverage` but don't stress about 100% coverage.
</file>

<file path="drizzle.config.ts">
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./packages/core/schema",
  dialect: "sqlite",
  dbCredentials: {
    url: "data/sqlite.db",
  },
});
</file>

<file path="apps/api/index.ts">
import { Elysia } from "elysia";
import { getContext, type Context } from "./context";
import { fooRoutes } from "./endpoints/foo";
import { env } from "./utils/env";
import { Boom, isBoom } from "@hapi/boom";

export const getApp = (ctx: Context) =>
  new Elysia()
    .error({ Boom })
    .onError(({ error, status }) => {
      if (isBoom(error)) {
        // don't repeat the status code
        const { statusCode: _statusCode, ...payload } = error.output.payload;
        return status(error.output.statusCode, payload);
      }

      return error;
    })
    .get("/", () => ({ message: "AI Starter API" }))
    .get("/health", () => ({ status: "ok" }))
    .use(fooRoutes(ctx));

export type App = ReturnType<typeof getApp>;

if (import.meta.main) {
  const ctx = getContext(env.DATABASE_URL);
  const app = getApp(ctx).listen(3000);

  const hostname: string = app.server?.hostname ?? "localhost";
  const port: number = app.server?.port ?? 3000;

  console.log(`ðŸ¦Š Elysia is running at ${hostname}:${port}`);
}
</file>

<file path="apps/cli/commands/add-foo.ts">
import { command } from "cleye";
import { getContext } from "../utils/app";
import { FLAGS } from "../utils/flags";

export const addFoo = command(
  {
    name: "add-foo",
    help: {
      description: "Add a new foo",
      examples: ['bun cli add-foo "My Foo Name"'],
    },
    flags: {
      ...FLAGS,
    },
    parameters: ["<foo name>"],
  },
  async (argv) => {
    const { app } = await getContext(argv.flags.database);
    const result = await app.createFoo(argv._.fooName);
    if (!result) {
      console.log(`\x1b[1m\x1b[31mFailed to create foo.\x1b[0m`);
      return;
    }
    console.log(`\x1b[1m\x1b[36mFoo Details:\x1b[0m`);
    console.log(`\x1b[33mID:\x1b[0m ${result.id}`);
    console.log(`\x1b[33mName:\x1b[0m ${result.name}`);
    console.log(`\x1b[33mCreated:\x1b[0m ${result.createdAt}`);
  }
);
</file>

<file path="apps/cli/commands/get-foo.ts">
import { command } from "cleye";
import { getContext } from "../utils/app";
import { FLAGS } from "../utils/flags";

export const getFoo = command(
  {
    name: "get-foo",
    help: {
      description: "Get the foo",
      examples: ["bun cli get-foo 1234"],
    },
    flags: {
      ...FLAGS,
    },
    parameters: ["<foo id>"],
  },
  async (argv) => {
    const { app } = await getContext(argv.flags.database);
    const result = await app.getFoo(argv._.fooId);
    if (!result) {
      console.log(
        `\x1b[1m\x1b[31mFoo with ID ${argv._.fooId} not found.\x1b[0m`
      );
      return;
    }
    console.log(`\x1b[1m\x1b[36mFoo Details:\x1b[0m`);
    console.log(`\x1b[33mID:\x1b[0m ${result.id}`);
    console.log(`\x1b[33mName:\x1b[0m ${result.name}`);
    console.log(`\x1b[33mCreated:\x1b[0m ${result.createdAt}`);
    console.log(`\x1b[33mUpdated:\x1b[0m ${result.updatedAt}`);
  }
);
</file>

<file path="apps/cli/utils/app.ts">
import { CoreAppService, AiAgentService } from "@ai-starter/app";
import { createDataAnalysisAgent } from "@ai-starter/app/agent/examples";
import { getDB, getRepos } from "@ai-starter/db";

export const getApp = async (repos: ReturnType<typeof getRepos>) => {
  return CoreAppService({ repos });
};

export const getAgent = async (repos: ReturnType<typeof getRepos>) => {
  const app = await getApp(repos);
  return AiAgentService({
    coreService: app,
    repos,
    agent: createDataAnalysisAgent(repos.foo),
  });
};

export const getContext = async (databaseUrl?: string) => {
  const db = await getDB(databaseUrl);
  const repos = await getRepos(db);
  const app = await getApp(repos);
  const agent = await getAgent(repos);
  return { repos, app, agent };
};
</file>

<file path="apps/cli/utils/render.ts">
import chalk, { type ChalkInstance } from "chalk";
import type { Message } from "@ai-starter/core";

/**
 * Renders a single message to stdout with appropriate formatting and colors.
 */
export function renderMessage(
  message: Message,
  opts: { skipTextParts: boolean } = { skipTextParts: false }
): void {
  const roleColors: Record<string, ChalkInstance> = {
    user: chalk.cyan,
    assistant: chalk.magenta,
    system: chalk.yellow,
    tool: chalk.green,
  };

  const roleColor = roleColors[message.role] || chalk.reset;

  // Check if there are any parts that should be rendered
  const hasRenderableParts = message.content.some(
    (part) => part.type !== "text" || !opts.skipTextParts
  );

  // Only render if there are parts to render
  if (!hasRenderableParts) {
    return;
  }

  // Write role prefix once before rendering parts
  process.stdout.write(`\n${roleColor.bold(message.role + ":")} `);

  for (const part of message.content) {
    switch (part.type) {
      case "text":
        if (opts.skipTextParts) break;
        process.stdout.write(part.text);
        break;
      case "tool-call":
        process.stdout.write(
          `${chalk.green(`Invoking ${part.toolName}`)} ${chalk.dim(`with input: ${JSON.stringify(part.input)}`)}`
        );
        break;
      case "tool-result":
        process.stdout.write(
          `${chalk.blue(`Result from ${part.toolName}:`)} ${chalk.dim(JSON.stringify(part.output))}`
        );
        break;
    }
  }
  process.stdout.write("\n");
}

/**
 * Renders an array of messages to stdout.
 */
export function renderMessages(messages: Message[]): void {
  for (const message of messages) {
    renderMessage(message);
  }
}

/**
 * Renders a text delta (streaming text fragment) to stdout.
 * Call startTextStream before the first delta to render the role prefix.
 */
export function renderTextDelta(delta: string): void {
  process.stdout.write(delta);
}

/**
 * Starts a text stream by rendering the role prefix.
 * Should be called before rendering text deltas.
 */
export function startTextStream(role: string): void {
  const roleColors: Record<string, ChalkInstance> = {
    user: chalk.cyan,
    assistant: chalk.magenta,
    system: chalk.yellow,
    tool: chalk.green,
  };

  const roleColor = roleColors[role] || chalk.reset;
  process.stdout.write(`\n${roleColor.bold(role + ":")} `);
}

/**
 * Ends a text stream by writing a newline.
 */
export function endTextStream(): void {
  process.stdout.write("\n");
}
</file>

<file path="packages/app/core/CoreAppService.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { mockFoos, testDB } from "@ai-starter/db/test-utils";
import { getRepos, type DB } from "@ai-starter/db";
import { CoreAppService } from "./CoreAppService";

describe("CoreAppService", () => {
  let db: DB;
  let repos: ReturnType<typeof getRepos>;
  let service: ReturnType<typeof CoreAppService>;

  beforeEach(async () => {
    db = await testDB();
    repos = await getRepos(db);
    service = CoreAppService({ repos: repos });
  });

  describe("getFoo", () => {
    it("should call the repository's get method with the correct id", async () => {
      const result = await service.getFoo("foo-1");
      expect(result).toEqual(mockFoos[0]);
    });

    it("should return null if the repository returns null", async () => {
      const result = await service.getFoo("non-existent-id");
      expect(result).toBeNull();
    });
  });

  describe("patchFoo", () => {
    it("should call the repository's patch method and return the result", async () => {
      const result = await service.patchFoo("foo-1", "Updated Name");
      expect(result).toEqual({
        id: "foo-1",
        name: "Updated Name",
        createdAt: mockFoos[0].createdAt,
        updatedAt: expect.any(Date),
      });
      expect(result.updatedAt.getTime()).toBeGreaterThan(
        mockFoos[0].updatedAt.getTime()
      );
    });

    it("should throw an error if business logic fails (e.g., name too short)", async () => {
      await expect(service.patchFoo("foo-1", "a")).rejects.toThrow(
        /Too small: expected string to have >=3 characters/
      );
    });
    describe("createFoo", () => {
      it("should validate and create a new Foo with generated id and timestamps", async () => {
        const result = await service.createFoo("New Foo Item");

        expect(result).toEqual({
          id: expect.stringMatching(
            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/
          ),
          name: "New Foo Item",
          createdAt: expect.any(Date),
          updatedAt: expect.any(Date),
        });

        // Verify it was actually persisted
        const fetched = await service.getFoo(result.id);
        expect(fetched).toEqual(result);
      });

      it("should throw an error if name is too short", async () => {
        await expect(service.createFoo("ab")).rejects.toThrow(
          /Too small: expected string to have >=3 characters/
        );
      });

      it("should throw an error if name is empty", async () => {
        await expect(service.createFoo("")).rejects.toThrow();
      });
    });
  });
});
</file>

<file path="packages/core/ports/repositories/FooRepository.ts">
import type { Foo, NewFoo } from "../../schema";

export interface FooRepository {
  get(id: string): Promise<Foo | null>;
  listAll(): Promise<Foo[]>;
  create(data: NewFoo): Promise<Foo>;
  patch(id: string, name: string): Promise<Foo>;
}
</file>

<file path="packages/db/db/index.ts">
import { drizzle } from "drizzle-orm/libsql";
import * as schema from "@ai-starter/core/schema";
import { pushSQLiteSchema } from "drizzle-kit/api";

export const getDB = (location: ":memory:" | (string & {}) = ":memory:") => {
  return drizzle(location, { schema, casing: "snake_case" });
};

export type DB = ReturnType<typeof getDB>;

export const migrateDB = async (db: DB) => {
  const { apply } = await pushSQLiteSchema(schema, db);
  await apply();
};
</file>

<file path="packages/db/repositories/FooRepository.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { fooSchema } from "@ai-starter/core";
import { DrizzleFooRepository } from "./FooRepository";
import type { DB } from "../db";
import { testDB } from "../test-utils/db";

describe("DrizzleFooRepository", () => {
  let db: DB;
  let repository: ReturnType<typeof DrizzleFooRepository>;

  beforeEach(async () => {
    db = await testDB();
    repository = DrizzleFooRepository({ db });
  });

  describe("get", () => {
    it("should return null when foo does not exist", async () => {
      const result = await repository.get("non-existent-id");
      expect(result).toBeNull();
    });

    it("should return foo when it exists", async () => {
      await db.insert(fooSchema).values({
        id: "test-id",
        name: "Test Foo",
        createdAt: new Date(),
      });

      const result = await repository.get("test-id");

      expect(result).not.toBeNull();
      expect(result?.id).toBe("test-id");
    });
  });

  describe("create", () => {
    it("should create a new foo", async () => {
      const now = new Date();
      now.setMilliseconds(0); // SQLite precision fix
      const foo = await repository.create({
        id: "new-id",
        name: "Test Foo",
        createdAt: now,
      });

      const result = await repository.get(foo.id);

      expect(result).not.toBeNull();
      expect(result?.id).toBe(foo.id);
      expect(foo.id).toBe("new-id");
      expect(foo.createdAt).toEqual(now);
    });

    it("should assign an ID and created date for a new foo", async () => {
      const x = await repository.create({ name: "Test Foo" });

      const result = await repository.get(x.id);

      expect(result).not.toBeNull();
      expect(result?.id).toBeDefined();
      expect(result?.createdAt).toBeDefined();

      await repository.patch(x.id, "Updated Name");

      const updatedResult = await repository.get(x.id);
      expect(updatedResult?.name).toBe("Updated Name");
    });
  });
});
</file>

<file path="packages/db/repositories/index.ts">
import type { DB } from "../db";
import { DrizzleFooRepository } from "./FooRepository";
import { DrizzleConversationRepository } from "./ConversationRepository";
import { DrizzleMessageRepository } from "./MessageRepository";

export * from "./FooRepository";
export * from "./ConversationRepository";
export * from "./MessageRepository";

export const getRepos = (db: DB) => {
  return {
    foo: DrizzleFooRepository({ db }),
    conversation: DrizzleConversationRepository({ db }),
    message: DrizzleMessageRepository({ db }),
  };
};
</file>

<file path="tests/cli.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { $ } from "bun";
import * as fs from "node:fs";
import * as path from "node:path";
import { setupDB } from "./utils/db";

describe("CLI e2e", () => {
  let tmpDir: string;
  let dbPath: string;

  beforeEach(async () => {
    ({ tmpDir, dbPath } = await setupDB("cli-test-"));
  });

  it("should add, get, patch, and get again a foo", async () => {
    const cliPath = path.resolve(__dirname, "../apps/cli/index.ts");

    console.log(
      `bun ${cliPath} add-foo "Initial Foo" --database file:${dbPath}`
    );
    // 1. Add a foo
    const addResult =
      await $`bun ${cliPath} add-foo "Initial Foo" --database file:${dbPath}`.text();

    expect(addResult).toContain("Foo Details:");
    expect(addResult).toContain("ID:");
    expect(addResult).toContain("Initial Foo");
    expect(addResult).toContain("Created:");

    // Extract the ID from the output (strip ANSI codes)
    const idMatch = addResult.match(/ID:[^\n]*?([a-f0-9-]{36})/);
    expect(idMatch).not.toBeNull();
    const fooId = idMatch![1];
    if (!fooId) throw new Error("Failed to extract foo ID");

    // 2. Get the foo
    const getResult =
      await $`bun ${cliPath} get-foo ${fooId} --database file:${dbPath}`.text();

    expect(getResult).toContain("Foo Details:");
    expect(getResult).toContain(fooId);
    expect(getResult).toContain("Initial Foo");
    expect(getResult).toContain("Created:");
    expect(getResult).toContain("Updated:");

    // 3. Patch the foo
    const patchResult =
      await $`bun ${cliPath} patch-foo ${fooId} "Updated Foo" --database file:${dbPath}`.text();

    expect(patchResult).toContain("Foo Details:");
    expect(patchResult).toContain(fooId);
    expect(patchResult).toContain("Updated Foo");
    expect(patchResult).toContain("Created:");
    expect(patchResult).toContain("Updated:");

    // 4. Get the foo again to verify the update
    const finalGetResult =
      await $`bun ${cliPath} get-foo ${fooId} --database file:${dbPath}`.text();

    expect(finalGetResult).toContain("Foo Details:");
    expect(finalGetResult).toContain(fooId);
    expect(finalGetResult).toContain("Updated Foo");
    expect(finalGetResult).toContain("Created:");
    expect(finalGetResult).toContain("Updated:");

    // Cleanup
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("should handle get with non-existent id", async () => {
    const cliPath = path.resolve(__dirname, "../apps/cli/index.ts");

    const getResult =
      await $`bun ${cliPath} get-foo non-existent-id --database file:${dbPath}`.text();

    expect(getResult).toContain("not found");

    // Cleanup
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  it("should handle patch with non-existent id", async () => {
    const cliPath = path.resolve(__dirname, "../apps/cli/index.ts");

    const patchResult =
      await $`bun ${cliPath} patch-foo non-existent-id "New Name" --database file:${dbPath}`.text();
    console.log("Patch Result:", patchResult);

    expect(patchResult).toContain("not found");

    // Cleanup
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });
});
</file>

<file path="apps/api/endpoints/foo.test.ts">
import { describe, it, expect, beforeEach } from "bun:test";
import { testDB, mockFoos } from "@ai-starter/db/test-utils";
import { getRepos, type DB } from "@ai-starter/db";
import { CoreAppService } from "@ai-starter/app";
import { getApp } from "..";

describe("Foo API endpoints", () => {
  let db: DB;
  let app: ReturnType<typeof getApp>;

  beforeEach(async () => {
    db = await testDB();

    app = getApp({ app: CoreAppService({ repos: getRepos(db) }) });
  });

  describe("GET /foos/:id", () => {
    it("should return a foo when it exists", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos/foo-1")
      );

      expect(response.status).toBe(200);
      const body = await response.json();
      expect(body).toEqual({
        id: mockFoos[0].id,
        name: mockFoos[0].name,
        createdAt: mockFoos[0].createdAt.toISOString(),
        updatedAt: mockFoos[0].updatedAt.toISOString(),
      });
    });

    it("should return 404 when foo does not exist", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos/non-existent-id")
      );

      expect(response.status).toBe(404);
      const body = await response.json();
      expect(body).toEqual({
        error: "Not Found",
        message: "Foo with ID non-existent-id not found",
      });
    });
  });

  describe("POST /foos", () => {
    it("should create a new foo", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: "New Foo Item" }),
        })
      );

      expect(response.status).toBe(201);
      const body = await response.json();
      expect(body).toEqual({
        id: expect.stringMatching(
          /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/
        ),
        name: "New Foo Item",
        createdAt: expect.any(String),
        updatedAt: expect.any(String),
      });
    });

    it("should reject foo with name too short", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: "ab" }),
        })
      );

      expect(response.status).toBe(422);
    });

    it("should reject foo without name", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({}),
        })
      );

      expect(response.status).toBe(422);
    });
  });

  describe("PATCH /foos/:id", () => {
    it("should update a foo's name", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos/foo-1", {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: "Updated Name" }),
        })
      );

      expect(response.status).toBe(200);
      const body = await response.json();
      expect(body).toEqual({
        id: "foo-1",
        name: "Updated Name",
        createdAt: mockFoos[0].createdAt.toISOString(),
        updatedAt: expect.any(String),
      });
    });

    it("should return 404 when foo does not exist", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos/non-existent-id", {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: "Updated Name" }),
        })
      );

      expect(response.status).toBe(404);
      const body = await response.json();
      expect(body).toEqual({
        error: "Not Found",
        message: "Foo with ID non-existent-id not found",
      });
    });

    it("should reject update with name too short", async () => {
      const response = await app.handle(
        new Request("http://localhost/foos/foo-1", {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name: "ab" }),
        })
      );

      expect(response.status).toBe(422);
    });
  });
});
</file>

<file path="apps/cli/commands/patch-foo.ts">
import { command } from "cleye";
import { getContext } from "../utils/app";
import { FLAGS } from "../utils/flags";
import type { Foo } from "@ai-starter/core";
import { isBoom } from "@hapi/boom";

export const patchFoo = command(
  {
    name: "patch-foo",
    help: {
      description: "Patch the foo",
      examples: ["bun cli patch-foo 1234 'New Name'"],
    },
    flags: {
      ...FLAGS,
      name: {
        type: String,
        alias: "n",
        description: "New name for the foo",
        required: true,
      },
    },
    parameters: ["<foo id>", "<foo name>"],
  },
  async (argv) => {
    const { app } = await getContext(argv.flags.database);
    let result: Foo | undefined;
    try {
      result = await app.patchFoo(argv._.fooId, argv._.fooName);
    } catch (error) {
      if (!isBoom(error) || error.output.statusCode !== 404) {
        throw error;
      }
      // continue to handle not found case below
    }
    if (!result) {
      console.log(
        `\x1b[1m\x1b[31mFoo with ID ${argv._.fooId} not found.\x1b[0m`
      );
      return;
    }
    console.log(`\x1b[1m\x1b[36mFoo Details:\x1b[0m`);
    console.log(`\x1b[33mID:\x1b[0m ${result.id}`);
    console.log(`\x1b[33mName:\x1b[0m ${result.name}`);
    console.log(`\x1b[33mCreated:\x1b[0m ${result.createdAt}`);
    console.log(`\x1b[33mUpdated:\x1b[0m ${result.updatedAt}`);
  }
);
</file>

<file path="apps/cli/package.json">
{
  "name": "@ai-starter/cli",
  "module": "index.ts",
  "bin": {
    "ai-starter": "./index.ts"
  },
  "devDependencies": {
    "@types/bun": "latest"
  },
  "peerDependencies": {
    "typescript": "^5"
  },
  "private": true,
  "type": "module",
  "dependencies": {
    "@ai-starter/app": "workspace:*",
    "@ai-starter/core": "workspace:*",
    "@ai-starter/db": "workspace:*",
    "@hapi/boom": "^10.0.1",
    "chalk": "^5.6.2",
    "cleye": "^2.0.0",
    "ora": "^9.0.0"
  }
}
</file>

<file path="packages/db/repositories/FooRepository.ts">
import { fooSchema, type FooRepository } from "@ai-starter/core";
import type { DB } from "../db";
import { eq } from "drizzle-orm";
import { notFound, badImplementation } from "@hapi/boom";

interface Deps {
  db: DB;
}

export const DrizzleFooRepository = ({ db }: Deps): FooRepository => ({
  async get(id: string) {
    const result = await db.query.fooSchema.findFirst({
      where: eq(fooSchema.id, id),
    });
    return result ?? null;
  },
  async create(data) {
    const [result] = await db.insert(fooSchema).values(data).returning();
    if (!result) throw badImplementation("Failed to create Foo");
    return result;
  },
  async patch(id: string, name: string) {
    const [result] = await db
      .update(fooSchema)
      .set({ name })
      .where(eq(fooSchema.id, id))
      .returning();
    if (!result) {
      throw notFound(`Foo with ID ${id} not found`, { id });
    }
    return result;
  },
  async listAll() {
    const results = await db.query.fooSchema.findMany();
    return results;
  },
});
</file>

<file path="packages/db/test-utils/db.ts">
import { getDB, migrateDB } from "../db";
import {
  DrizzleFooRepository,
  DrizzleConversationRepository,
  DrizzleMessageRepository,
} from "../repositories";
import { doSeedAll } from "./seed/all";

export const testDB = async (opts: { seed?: boolean } = {}) => {
  const { seed = true } = opts;
  const db = getDB(":memory:");
  await migrateDB(db);
  if (seed) await doSeedAll(db);
  return db;
};

export const getRepos = async () => {
  const db = await testDB();
  return {
    db,
    repos: {
      foo: DrizzleFooRepository({ db }),
      conversation: DrizzleConversationRepository({ db }),
      message: DrizzleMessageRepository({ db }),
    },
  };
};
</file>

<file path="package.json">
{
  "name": "ai-starter",
  "module": "index.ts",
  "type": "module",
  "private": true,
  "workspaces": [
    "packages/*",
    "apps/*",
    "tests"
  ],
  "scripts": {
    "db:studio": "bunx drizzle-kit studio",
    "db:push": "bunx drizzle-kit push",
    "cli": "bun apps/cli/index.ts",
    "api": "bun apps/api/src/index.ts",
    "test": "bun test",
    "typecheck": "tsc --build packages/*/tsconfig.json apps/*/tsconfig.json tests/tsconfig.json",
    "lint": "eslint . && prettier --check .",
    "lint:fix": "bun format && eslint --fix --unsafe .",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "check": "bun test && bun run typecheck && bun run lint"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "drizzle-kit": "^0.31.6",
    "eslint": "^9.39.1",
    "prettier": "^3.2.5",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.46.4"
  }
}
</file>

</files>
